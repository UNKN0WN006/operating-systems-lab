# A2_06_07 — Program Flow, Deadlock Avoidance and Viva Questions

## Header

Team: 06

Team Members:
- Anay Saha — Roll No: 002311001054
- Sushar Hembram — Roll No: 002311001041
- Debarshi Mondal — Roll No: 002311001055

Date: 18.09.2025

Assignment: Avoiding DEADLOCK using Thread Programming

Source file: `A2_06_07.c`

---

## Objective

- Demonstrate avoiding deadlock using POSIX threads and mutexes.
- Maintain three global totals (`t1`, `t2`, `t3`) protected by three mutexes (`m1`, `m2`, `m3`).
- Create four threads (Th1, Th2, Th3, Th4):
  - Th1, Th2, Th3 perform random transfers between totals.
  - Th4 displays totals and grand total consistently.
- Program runs indefinitely and prints enough information to show no deadlock.

---

## Quick build & run

Build:

```bash
gcc A2_06_07.c -o A2_06_07 -lpthread
```

Run:

```bash
./A2_06_07
# program runs indefinitely; Ctrl-C to stop
```

---

## High-level program flow

1. `main()`
   - Initializes global totals (`t1`, `t2`, `t3`) to 100000 each.
   - Initializes mutexes (`m1`, `m2`, `m3`) using `PTHREAD_MUTEX_INITIALIZER`.
   - Seeds RNG with `srand(time(NULL))`.
   - Creates four threads:
     - `thread1` runs `th1_func`.
     - `thread2` runs `th2_func`.
     - `thread3` runs `th3_func`.
     - `thread4` runs `th4_func` (display thread).
   - Joins all threads (program blocks until interrupted).

2. `th1_func` (Th1):
   - Loop forever.
   - Generate random `amt` in [1,10] and a random `choice` (0 or 1).
   - If `choice==0`, move `amt` from `t1` to `t2`.
   - Else, move `amt` from `t1` to `t3`.
   - Lock required mutexes before updating totals, then unlock.
   - Sleep `usleep(300000)` between iterations.

3. `th2_func` (Th2):
   - Similar to Th1 but `amt` in [1,20] and moves from `t2` to `t1` or `t3`.
   - Uses `usleep(400000)`.

4. `th3_func` (Th3):
   - `amt` in [1,30], moves from `t3` to `t1` or `t2`.
   - Uses `usleep(500000)`.

5. `th4_func` (Th4): display thread
   - Every second: lock all three mutexes, read `t1,t2,t3`, compute `sum`, then unlock in reverse order.
   - Print values so they are consistent (no partial updates while printing).

---

## Mutex locking order and deadlock avoidance (explicit)

- The program enforces a consistent lock ordering to avoid circular wait:
  - Whenever two mutexes are needed, threads acquire them by the same order (the code uses `pthread_mutex_lock(&m1)` before `m2` or `m3` in operations that involve `t1` and another total).
  - The display thread acquires `m1`, then `m2`, then `m3` when reading all totals.

- Why this avoids deadlock:
  - Deadlock requires circular wait (A holds lock1 and waits for lock2 while B holds lock2 and waits for lock1). By establishing a global ordering (m1 < m2 < m3) and always acquiring locks in that order, circular waits are prevented.

- How to intentionally create deadlock (for demonstration):
  - If Th1 locks `m1` then `m2`, but Th2 locks `m2` then `m1`, there is a possibility both hold the first lock and wait indefinitely for the second — a deadlock.

- Note: The code currently acquires pairs consistently (m1 then m2, or m1 then m3, or m2 then m3) and the display thread locks all three in order (m1, m2, m3), so circular wait cannot occur.

---

## Mapping code to assignment checklist

- Three global totals initialized to 100000: `t1`, `t2`, `t3` — present.
- Three mutexes: `m1`, `m2`, `m3` — present.
- Four threads: `Th1`, `Th2`, `Th3`, `Th4` — present and created in `main`.
- Each worker thread locks relevant mutexes before modifying totals and unlocks afterwards — implemented.
- Display thread prints totals and grand total while holding all relevant locks — implemented.
- Program runs forever — worker loops are infinite and `main` joins threads.
- Comments describing lock order and deadlock avoidance are present near the top of the source file — implemented.

---

## Sample program output (excerpt)

(Excerpt from a sample run — see `A2_06_07.c` header comments for full transcript.)

```
Starting program...
Initial: t1=100000, t2=100000, t3=100000

Th1: Moving 5 from t1
Th1: t1=99995, t3=100005
All threads started
...
--- Display Thread ---
t1=100003, t2=100000, t3=99997
Total=300000
--- End Display ---
```

- The output shows frequent transfer messages from worker threads and periodic consistent snapshots from the display thread.
- The grand total remains constant (300000) demonstrating conservation of amount and thread-safe updates.

---

## Testing & validation suggestions

- Run the program and watch the display thread output to confirm totals sum to 300000 always.
- To test deadlock resilience:
  - Create a modified branch of the code that intentionally reverses lock order in one thread (e.g., Th2 locks `m2` then `m1`). Observe that the program can deadlock — useful for demonstration but **do not** submit deadlocked code.
- Stress test by decreasing `usleep` durations (e.g., to 10ms) to increase contention and verify no deadlock occurs.
- Use `htop` or `ps` to inspect threads during run; count threads and verify CPU utilization.
- Ensure `perror` is used on thread creation errors (already present in code).

---

## Notes on sleeps and output

- `usleep` in worker threads and `sleep(1)` in display thread are deliberate to:
  - Slow down output for human readability.
  - Reduce busy-loop CPU usage and allow concurrency scheduling.
- The assignment does not prohibit sleeps; they are common in teaching/demo programs.

---

## Suggested improvements (optional)

- Add signal handling (SIGINT) to gracefully cancel threads and clean up mutexes.
- Use `pthread_mutex_trylock` with a timeout to avoid blocking indefinitely (alternative deadlock-avoidance technique).
- Add a verbose flag or log level to reduce output during long runs.

---

## Important viva questions (with short model answers)

1. Q: What is a deadlock and what are its necessary conditions?
   - A: Deadlock is a state where two or more processes/threads wait indefinitely for resources held by each other. Necessary conditions: mutual exclusion, hold-and-wait, no preemption, circular wait.

2. Q: How does your program avoid deadlock?
   - A: By enforcing a strict global lock acquisition order (m1 < m2 < m3). Any thread needing multiple locks acquires them in that order, preventing circular wait.

3. Q: Why is the order of acquiring mutexes important?
   - A: Because inconsistent order across threads can create circular wait cycles leading to deadlock. A consistent ordering prevents cycles.

4. Q: Could the display thread cause starvation or delays? How do you mitigate it?
   - A: The display thread locks all three mutexes briefly and releases them; since it sleeps 1s between snapshots and holds locks for minimal time, it shouldn't starve worker threads. Using short critical sections mitigates blocking.

5. Q: Why are `usleep`/`sleep` calls used in the threads?
   - A: To slow iteration rate for readable output and to avoid busy-waiting that would consume CPU. They also reduce contention frequency, making behavior easier to observe.

6. Q: How would you demonstrate a deadlock intentionally for teaching purposes?
   - A: Modify one thread to acquire locks in reverse order (m2 before m1) and run; under the right timing both threads can block waiting for the other's lock.

7. Q: What alternative techniques exist to avoid deadlock besides lock ordering?
   - A: Try-locking with backoff, using lock hierarchies or resource allocation graphs, deadlock detection and recovery, using a single global lock, or redesigning to reduce lock granularity.

8. Q: How do mutexes differ from semaphores?
   - A: Mutexes are binary locks used to enforce mutual exclusion with ownership semantics (same thread should unlock). Semaphores can be counting and do not enforce ownership.

9. Q: What is the difference between process-level and thread-level deadlock?
   - A: Conceptually similar; process-level involves separate processes (and often different resources), thread-level occurs within the same process among threads. Thread deadlocks can share memory and resources more tightly.

10. Q: How would you modify the program to print per-thread statistics (like number of transfers performed)?
    - A: Add counters (atomic or protected by mutex) per thread to count successful transfers, then print these counters in the display thread under the same locking regime.

---

## Deliverables

- `A2_06_07.c` — source code (already in `day7_ass7`).
- `A2_06_07_FLOW.md` — this file (added beside the code).

---

If you'd like, I can also:
- Add SIGINT handling in `A2_06_07.c` to exit gracefully and join threads.
- Produce a short `README.md` in `day7_ass7` with build/test instructions and demonstration commands.

Which of these would you like next?