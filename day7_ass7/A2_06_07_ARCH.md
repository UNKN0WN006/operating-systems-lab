# A2_06_07 — Architecture and Flowchart

This document describes the architecture, key components, data structures, threading model, and flowchart for `A2_06_07.c` (Assignment 7 — Avoiding Deadlock with Threads).

## 1. Purpose

Provide a clear, concise architecture description and visual flow of how the program works so reviewers and examiners can quickly understand the design and reasoning behind lock ordering and thread interactions.

---

## 2. Components

- Global state
  - `int t1, t2, t3;` — three totals initialized to 100000 each.

- Synchronization
  - `pthread_mutex_t m1, m2, m3;` — one mutex protecting each total.

- Threads
  - `Th1` (function `th1_func`) — repeatedly picks a random amount (1..10) and transfers from `t1` to `t2` or `t3`.
  - `Th2` (function `th2_func`) — repeatedly picks a random amount (1..20) and transfers from `t2` to `t1` or `t3`.
  - `Th3` (function `th3_func`) — repeatedly picks a random amount (1..30) and transfers from `t3` to `t1` or `t2`.
  - `Th4` (function `th4_func`) — display thread: periodically locks all mutexes, reads `t1,t2,t3` and prints the values and grand total.

- Utilities
  - `srand(time(NULL))` for randomness
  - `usleep()` in worker threads and `sleep(1)` in the display thread to pace activity and make output readable

---

## 3. Data access patterns

- When a transfer involves two totals (source and destination), the thread must lock the mutex protecting both totals before performing the update.
- All code paths that acquire more than one mutex must do so in the same order to prevent circular wait. In our program that order is:

  Acquire locks in the numeric order: `m1` then `m2` then `m3` (if needed).

- Examples:
  - Th1 moving from `t1` to `t2`: lock `m1`, then `m2`.
  - Th1 moving from `t1` to `t3`: lock `m1`, then `m3`.
  - Th2 moving from `t2` to `t1`: code locks `m1` then `m2` (consistent ordering).
  - Display thread: locks `m1` then `m2` then `m3` to read all totals consistently.

---

## 4. Thread interaction and invariants

- Invariant: `t1 + t2 + t3 == 300000` always (sum conserved by transfers).
- Threads only modify totals while holding the appropriate mutex(es).
- Display thread reads totals while holding all three mutexes so snapshots are consistent.
- Lock ordering prevents circular wait; therefore deadlock cannot occur under correct code paths.

---

## 5. Flowchart (Mermaid)

Below is a Mermaid flowchart representing the main flow and thread activities. If your viewer supports Mermaid, you can render it; otherwise an ASCII fallback follows.

```mermaid
flowchart TB
  A[main()] --> B[init t1,t2,t3]
  B --> C[init mutexes m1,m2,m3]
  C --> D[create Th1]
  C --> E[create Th2]
  C --> F[create Th3]
  C --> G[create Th4 (display)]
  D --> H[Th1 loop]
  E --> I[Th2 loop]
  F --> J[Th3 loop]
  G --> K[Th4 loop (display)]

  subgraph Th1_proc [Th1 loop]
    H1[choose amt = rand(1..10)]
    H2[choose dest (t2 or t3)]
    H3[lock m1; lock mX]
    H4[if t1 >= amt: t1 -= amt; tX += amt]
    H5[unlock mX; unlock m1]
    H6[usleep(300ms)]
    H1 --> H2 --> H3 --> H4 --> H5 --> H6 --> H1
  end

  subgraph Th2_proc [Th2 loop]
    I1[choose amt = rand(1..20)]
    I2[choose dest (t1 or t3)]
    I3[lock m1/m2/m3 in order]
    I4[do transfer]
    I5[unlock in reverse]
    I6[usleep(400ms)]
    I1 --> I2 --> I3 --> I4 --> I5 --> I6 --> I1
  end

  subgraph Th3_proc [Th3 loop]
    J1[choose amt = rand(1..30)]
    J2[choose dest (t1 or t2)]
    J3[lock m1/m2/m3 in order]
    J4[do transfer]
    J5[unlock in reverse]
    J6[usleep(500ms)]
    J1 --> J2 --> J3 --> J4 --> J5 --> J6 --> J1
  end

  subgraph Th4_proc [Display loop]
    K1[lock m1; lock m2; lock m3]
    K2[read a=t1,b=t2,c=t3]
    K3[unlock m3; unlock m2; unlock m1]
    K4[print a,b,c and sum]
    K5[sleep(1s)]
    K1 --> K2 --> K3 --> K4 --> K5 --> K1
  end
```

### ASCII flow (fallback)

main()
  |
  +-- init t1,t2,t3
  |
  +-- init m1,m2,m3
  |
  +-- spawn Th1 ---> [Th1 loop: choose amt; lock m1->mX; transfer; unlock; usleep]
  |
  +-- spawn Th2 ---> [Th2 loop: choose amt; lock m1/m2/m3 order; transfer; unlock; usleep]
  |
  +-- spawn Th3 ---> [Th3 loop: choose amt; lock m1/m2/m3 order; transfer; unlock; usleep]
  |
  +-- spawn Th4 ---> [Th4 loop: lock m1->m2->m3; read totals; unlock; print; sleep(1)]

---

## 6. Sequence and timing considerations

- Worker threads lock for a very short time (only while updating integers and printing result). The display thread holds locks briefly while reading three integers. Short critical sections help minimize blocking and contention.
- Random sleep intervals (300ms/400ms/500ms) desynchronize workers and reduce lock contention probability.

---

## 7. Alternative designs (trade-offs)

- Single global mutex protecting all totals: simpler logic, but reduces concurrency.
- Per-total mutex (current design): better concurrency but requires careful ordering to avoid deadlock.
- Try-lock and backoff: threads can use `pthread_mutex_trylock` and, on failure, release acquired locks and retry after a delay; reduces deadlock risk at cost of complexity.

---

## 8. Where to find things in code

- `t1,t2,t3` variables near top of `A2_06_07.c`.
- Mutex initializers `pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;` etc.
- Thread functions: `th1_func`, `th2_func`, `th3_func`, `th4_func`.
- Main thread: creates threads with `pthread_create` and prints initial values.

---

## 9. Notes for reviewers and examiners

- The program aims to demonstrate correct lock ordering to avoid deadlock while preserving concurrency.
- The display snapshots always show the grand total conserved, which indicates correct critical-section usage.
- For pedagogical demonstration, you may intentionally alter lock ordering in one worker to show deadlock — but revert before submission.

---

If you want, I can also:
- Generate a PNG/SVG of the flowchart (requires a Mermaid renderer or external tool; I can produce an ASCII art PNG if you want). 
- Add signal handling to `A2_06_07.c` to cleanly stop threads and print a final summary.

Which would you like next?