# A2_06_04 — Program Flow, Behaviour & Viva Questions

This document describes the program flow, behaviour, verification steps and viva questions for `A2_06_04.c` (Assignment 4 — Memory Mapping).

## Quick summary

- Purpose: Demonstrate use of `mmap()` to memory-map a large file (8 GB), write a random byte at a random offset using the file descriptor, read the byte from the mapped memory, and verify correctness. Observe page faults (minor & major) with `sar -B 1` while the program runs.
- Key syscalls: `open`, `fallocate`, `mmap`, `lseek`, `write`, `munmap`.
- Execution: compile with `gcc A2_06_04.c` and run `./a.out` in a system with enough disk space.

## Inputs & outputs

- Input: No command-line arguments. Program creates `bigfile.bin` in the current directory and operates on it.
- Output: Repeated lines of the form:

```
Verified: 0x38 at offset 0x2c8d5afc
```

- If verification fails, the program prints an error message and exits, e.g.:

```
ERROR: Verification failed! Expected 0x12, got 0x34 at offset 0x12345678
```

## High-level program flow

1. Seed RNG with `srand(time(NULL))`.
2. Open (or create) `bigfile.bin` with `open("bigfile.bin", O_CREAT|O_RDWR, 0666)`.
3. Allocate disk space for the file using `fallocate(fd, 0, 0, FILE_SIZE)` where `FILE_SIZE` = 8GB.
   - If fallocate fails, the program currently prints an error and exits.
4. Map the entire file into the process virtual address space using `mmap(NULL, FILE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)`.
   - If mapping fails, print an error and exit.
5. Enter an infinite loop:
   - Generate a random offset `offset = rand() % FILE_SIZE` and a random byte `X = rand() % 256`.
   - Write the byte `X` to the file at `offset` using `lseek(fd, offset, SEEK_SET)` and `write(fd, &X, 1)`.
   - Read `X_prime` from the mapped region `mapped_file[offset]`.
   - Compare `X` and `X_prime`; print verification success or error and exit on mismatch.
6. On termination (error or external kill), `munmap(mapped_file, FILE_SIZE); close(fd);` and return.

## Important implementation notes

- The program uses `MAP_SHARED` so writes to the mapped memory are visible to other processes and are propagated to the underlying file.
- The program writes via `write()` on the file descriptor rather than writing directly into the mapped region; the verification reads from the mapping to ensure the page cache/reflection is consistent.
- Because the file is very large (8GB), the mapping may create many page faults as pages are touched. Observing `sar -B 1` (page-fault metrics) while the program runs demonstrates the paging behaviour.

## Observability & verification

- To observe page faults in another terminal before running the program:

```bash
sar -B 1
```

- Typical fields of interest in the `sar -B` output:
  - `fault/s` — page faults per second.
  - `majflt/s` — major faults per second (require I/O).
  - `pgpgin/s` and `pgpgout/s` — pages paged in/out per second.

- While `./a.out` performs random writes and reads across an 8GB mapping you should see spikes in `fault/s` and possibly `majflt/s` (if pages require disk I/O).

- The assignment sample includes captured `sar -B` output showing large `fault/s` values and occasional `majflt/s` spikes (depending on underlying OS and available RAM).

## Edge cases & caveats

- Disk space: Creating an 8GB file requires sufficient disk space. In constrained environments, `fallocate` may fail.
- mmap of a very large file may fail if system limits are exceeded; mapping 8GB on a 32-bit system would fail.
- The code uses `rand() % FILE_SIZE` — `rand()` returns values up to RAND_MAX (~2^31-1); on platforms where `FILE_SIZE` exceeds RAND_MAX, offsets will be constrained. For robust random offsets across > 2GB, use `uint64_t` RNG (e.g., `random()` or `arc4random_buf` or combine two `rand()` calls).
- Performance: touching many random pages will thrash the page cache and cause high I/O; results depend heavily on available RAM and filesystem.

## Verification checklist

- [ ] Ensure `bigfile.bin` can be created and `fallocate` succeeds.
- [ ] Run `sar -B 1` in another terminal before `./a.out` and observe `fault/s` spikes while program runs.
- [ ] Confirm that repeated `Verified:` messages are printed.
- [ ] Test scenario where mapped memory is read directly without performing `write` to compare behavior.

## Testing suggestions

- For quick tests use a smaller `FILE_SIZE` (e.g., 64MB) by changing the `#define FILE_SIZE` to speed up iteration and avoid large disk usage while developing.
- For deterministic reproducible testing, seed the RNG with a fixed value.

---

## Viva questions (with short model answers)

1. Q: Why use `mmap()` instead of buffered `pread`/`pwrite` calls?
   - A: `mmap()` maps file pages into the process address space and allows the kernel to lazily load only the accessed pages. It can be more efficient for random reads/writes and allows convenient pointer-based access.

2. Q: What does `MAP_SHARED` mean and why is it used here?
   - A: `MAP_SHARED` makes modifications to the mapping visible to other processes mapping the same file and causally propagated to the underlying file. It's used to demonstrate shared mapping behaviour and page cache effects.

3. Q: Why call `fallocate()` before `mmap()`?
   - A: `fallocate()` ensures the file has allocated space on disk and can avoid sparse-file traps. It reduces the chance of ENOSPC or SIGBUS when accessing pages. Also helps observe I/O behavior predictably.

4. Q: How and why do page faults happen with `mmap()`?
   - A: On first access to a mapped page that isn't resident, the CPU traps to the kernel (minor page fault) which loads the page from disk or zero-fills it. If disk I/O is required to fetch the page from storage it's a major fault.

5. Q: What is the difference between a minor and a major page fault?
   - A: Minor page fault: page is not mapped into the process page table but resides in memory (e.g., shared page) or can be resolved without disk I/O. Major page fault: the page must be read from disk/backing store, which incurs I/O and is slower.

6. Q: Why could `mapped_file[offset]` differ from the byte written via `write()` at `offset`?
   - A: If write was buffered and not flushed, or ordering of caches/visibility issues, the mapping might reflect a stale value. However with `MAP_SHARED` and immediate write using `write()`, the kernel ensures coherency via page cache — differences are possible if the write hasn't been committed or if the offset arithmetic overflows.

7. Q: What errors must be handled when using `mmap()` on a large file?
   - A: `mmap` can fail with `ENOMEM` if the mapping can't be created; `SIGBUS` can occur when accessing a mapped region whose underlying file block has been truncated. Also `fallocate` can fail with `ENOSPC`.

8. Q: Why might `fallocate()` succeed but subsequent writes still fail with `EIO` or `SIGBUS`?
   - A: Underlying storage issues (device faults), or if the file is truncated concurrently by another process. Some filesystems may not support `fallocate` fully.

9. Q: How would you measure the cost of a single random page touch?
   - A: Use `gettimeofday` or `clock_gettime` around a single mapped read and check `sar -B` or `perf stat` counters, and measure latency distribution over many touches.

10. Q: What are safer alternatives for very large memory-backed files when you don't have enough RAM?
    - A: Use smaller working sets (tile/block accesses), limit the number of concurrently mapped pages, use buffered I/O with careful caching, or use asynchronous I/O to overlap page faults with computation.

---

If you want, I can now:
- Create `day4_ass4/A2_06_04_ARCH.md` with a Mermaid flowchart and detailed architecture notes (I will create it next).  
- Patch the C source to use a smaller `FILE_SIZE` for quick testing and to use a 64-bit-safe RNG for offsets.  

Say "create architecture doc" or ask for the quick patch to `A2_06_04.c`.